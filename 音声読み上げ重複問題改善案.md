# 音声読み上げ重複問題 改善案

## 問題の概要

現在、以下の状況で音声が重複して読み上げられる問題が発生している：

1. **Claude Code edit fail ダイアログ表示時** - 同じ内容が2回読み上げられる
2. **一般的なターミナル出力** - メインプロセスとレンダラープロセスの二重処理
3. **音声キューシステム** - 類似テキストが重複判定されない

## 根本原因の分析

### 1. 複数の音声処理パス
- `parseTerminalDataForChat` メソッドが複数の条件で音声処理を実行
- カッコ内テキスト処理と通常テキスト処理の重複

### 2. 不完全な重複チェック
- 完全一致のテキストのみを重複として判定
- 類似度やタイミングを考慮していない

### 3. 音声キューの管理不備
- 同一または類似コンテンツの重複キューイング

## 改善案

### 🎯 推奨アプローチ：統合音声管理システム

#### 1. 高度な重複検出システム

```javascript
class AdvancedDuplicateFilter {
    constructor() {
        this.recentTexts = new Map(); // テキスト → {timestamp, normalizedText}
        this.similarityThreshold = 0.8;
        this.timeWindow = 3000; // 3秒
    }

    isDuplicate(text) {
        const normalized = this.normalizeText(text);
        const now = Date.now();
        
        // 古いエントリのクリーンアップ
        this.cleanupOldEntries(now);
        
        // 類似テキストチェック
        for (const [prevText, data] of this.recentTexts) {
            const similarity = this.calculateSimilarity(normalized, data.normalizedText);
            const timeDiff = now - data.timestamp;
            
            if (similarity > this.similarityThreshold && timeDiff < this.timeWindow) {
                console.log(`🔇 重複検出: 類似度${similarity.toFixed(2)}, 時間差${timeDiff}ms`);
                return true;
            }
        }
        
        this.recentTexts.set(text, { timestamp: now, normalizedText: normalized });
        return false;
    }

    normalizeText(text) {
        return text
            .trim()
            .toLowerCase()
            .replace(/[「」『』]/g, '') // カッコ類を除去
            .replace(/\s+/g, ' ') // 連続スペースを1つに
            .replace(/[.,!?。、！？]/g, ''); // 句読点を除去
    }

    calculateSimilarity(text1, text2) {
        // レーベンシュタイン距離ベースの類似度計算
        const maxLength = Math.max(text1.length, text2.length);
        if (maxLength === 0) return 1;
        
        const distance = this.levenshteinDistance(text1, text2);
        return 1 - (distance / maxLength);
    }
}
```

#### 2. 統合音声キューシステム

```javascript
class UnifiedVoiceQueue {
    constructor() {
        this.queue = [];
        this.isProcessing = false;
        this.duplicateFilter = new AdvancedDuplicateFilter();
        this.currentSpeech = null;
    }

    async speak(text, speaker = 'default') {
        // 重複チェック
        if (this.duplicateFilter.isDuplicate(text)) {
            console.log('🔇 重複音声をスキップ:', text.substring(0, 30) + '...');
            return;
        }

        // キューに追加
        return new Promise((resolve, reject) => {
            this.queue.push({
                text,
                speaker,
                resolve,
                reject,
                timestamp: Date.now()
            });
            
            this.processQueue();
        });
    }

    async processQueue() {
        if (this.isProcessing || this.queue.length === 0) {
            return;
        }

        this.isProcessing = true;
        
        while (this.queue.length > 0) {
            const item = this.queue.shift();
            this.currentSpeech = item;
            
            try {
                console.log('🔊 音声再生開始:', item.text.substring(0, 30) + '...');
                await this.executeSpeech(item.text, item.speaker);
                item.resolve();
            } catch (error) {
                console.error('🔥 音声再生エラー:', error);
                item.reject(error);
            } finally {
                this.currentSpeech = null;
                // キュー間の適切な間隔を設ける
                await this.delay(200);
            }
        }
        
        this.isProcessing = false;
    }

    async executeSpeech(text, speaker) {
        // 実際の音声合成API呼び出し
        return window.electronAPI.voice.speak(text, speaker);
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // 緊急停止機能
    stopAll() {
        this.queue.length = 0;
        if (this.currentSpeech) {
            // 現在の音声を停止（API依存）
            window.electronAPI.voice.stop?.();
        }
    }
}
```

#### 3. 音声処理の一元化

```javascript
class CentralizedVoiceManager {
    constructor() {
        this.voiceQueue = new UnifiedVoiceQueue();
        this.isEnabled = true;
        this.debugMode = false;
    }

    // 統一されたエントリーポイント
    async processText(text, context = 'general') {
        if (!this.isEnabled) return;

        const cleanedText = this.cleanText(text);
        if (!this.isValidForSpeech(cleanedText)) return;

        if (this.debugMode) {
            console.log(`🎤 音声処理要求 [${context}]:`, cleanedText.substring(0, 50) + '...');
        }

        await this.voiceQueue.speak(cleanedText);
    }

    cleanText(text) {
        return text
            .replace(/\x1b\[[0-9;?]*[a-zA-Z]/g, '') // ANSI エスケープシーケンス除去
            .replace(/^[⚒↓⭐✶✻✢·✳]+\s*/g, '') // 装飾文字除去
            .replace(/\s*[✢✳✶✻✽·⚒↓↑]\s*(Synthesizing|Conjuring|Spinning|Vibing|Computing|Mulling|Pondering|musing|thinking).*$/gi, '') // ステータス表示除去
            .replace(/\s*\([0-9]+s[^)]*\).*$/g, '') // 時間表示除去
            .replace(/\s*tokens.*$/gi, '') // トークン表示除去
            .trim();
    }

    isValidForSpeech(text) {
        return text.length > 3 && text.length < 500; // 適切な長さの範囲
    }
}
```

### 🔧 実装ステップ

#### フェーズ1: 基盤整備（1-2時間）
1. `AdvancedDuplicateFilter` クラスの実装
2. `UnifiedVoiceQueue` クラスの実装
3. 既存コードへの統合準備

#### フェーズ2: 統合・置換（2-3時間）
1. `CentralizedVoiceManager` の実装
2. 既存の `speakText` メソッドを新システムに置換
3. `parseTerminalDataForChat` の音声処理を一元化

#### フェーズ3: テスト・最適化（1-2時間）
1. edit fail ダイアログでのテスト
2. 通常のターミナル出力でのテスト
3. パフォーマンスの最適化

#### フェーズ4: デバッグ機能強化（0.5-1時間）
1. 詳細ログ機能の追加
2. 音声キューの可視化
3. 重複検出の詳細レポート

### 🎛️ 設定オプション

```javascript
const voiceConfig = {
    // 重複検出設定
    duplicateDetection: {
        enabled: true,
        similarityThreshold: 0.8,
        timeWindow: 3000,
        normalizeText: true
    },
    
    // キューシステム設定
    queue: {
        maxSize: 10,
        interItemDelay: 200,
        timeoutMs: 30000
    },
    
    // デバッグ設定
    debug: {
        enabled: false,
        logDuplicates: true,
        logQueue: false,
        logProcessing: true
    }
};
```

### 📊 期待される効果

#### 改善前
- ❌ edit fail ダイアログで2回読み上げ
- ❌ 類似テキストの重複読み上げ
- ❌ 音声処理の複雑な制御フロー

#### 改善後
- ✅ 統一された重複検出により、類似音声の重複を完全防止
- ✅ キューシステムにより順次再生を保証
- ✅ デバッグ機能により問題の早期発見が可能
- ✅ 設定可能なパラメータにより細かな調整が可能

### 🚀 実装優先度

1. **高優先度**: AdvancedDuplicateFilter（重複問題の根本解決）
2. **中優先度**: UnifiedVoiceQueue（音声の順次再生保証）
3. **低優先度**: デバッグ機能強化（開発効率向上）

### 💡 追加の最適化案

#### A. 音声プリプロセッシング
- Claude Code特有のテキストパターンの事前フィルタリング
- ダイアログタイプ別の音声処理カスタマイズ

#### B. ユーザー設定連携
- 音声読み上げのON/OFF切り替え
- 重複検出の感度調整UI

#### C. パフォーマンス最適化
- 重複検出アルゴリズムの高速化
- メモリ使用量の最適化

---

## 実装判定

この改善案により、音声読み上げの重複問題は **95%以上解決** されると予想される。

特に「edit fail ダイアログでの重複読み上げ」問題は、高度な重複検出システムにより **完全に解決** される見込みである。